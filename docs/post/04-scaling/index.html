<!DOCTYPE html>
<html>
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <base href="http://partisan.cloud">
    <title>Cluster Scalability: Lasp</title>

    
    <link type="text/css" href="/css/bootstrap.min.css" rel="stylesheet">

    
    <link type="text/css" href="/css/landing-page.css" rel="stylesheet">

    
    <link href="http://fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">

    <style>
    .navbar {
    border-color: #e7e7e7;
}

.content-section-a,
footer,
.navbar {
  background-color: #f8f8f8;
  color: #333;
}

.navbar a:link,
.navbar-default .navbar-nav>li>a {
  color: #777;
}

.navbar a:hover,
.navbar-default .navbar-nav>li>a:hover {
  color: rgb(51, 51, 51);
}

.content-section-b {
  background-color: white;
  color: #333;
}

body {
  color: rgb(51, 51, 51);
}

.header-container {
  margin-left: auto;
  margin-right: auto;
}

.header-container h1,
.header-container h2,
.header-container h3,
.header-container h4 {
  color: rgb(51, 51, 51);
}

.graph {
  margin: 10px 0px 10px 0px;
  border: 1px solid #e7e7e7;
  width: 100%;
}

.content-section-a, .content-section-b {
  padding: 30px;
}

.head-container {
  border-bottom: 1px solid #e7e7e7;
}

p {
  line-height: 24px;   /* within paragraph */
}

.final {
  border-top: 1px solid #e7e7e7;
}
  </style>

</head>
<body>


<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="page-scroll navbar-brand" href="#intro">Partisan</a>
        </div>
        
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a class="page-scroll" href=http://github.com/lasp-lang/partisan>GitHub</a>
                </li>
                
            </ul>
        </div>
        
    </div>
    
</nav>


<section id="services">
   <div class="content-section-a">

      <div class="container">

        <div class="row">
          <div>
            <hr class="section-heading-spacer">
            <div class="clearfix"></div>
            <h2 class="section-heading">Cluster Scalability: Lasp</h2>
            <p><a href="http://www.github.com/lasp-lang/lasp">Lasp</a> is a programming framework
designed for large scale coordination-free programming. Applications in Lasp
are written using shared state; this shared state is stored in an underlying
key-value store and is replicated between all nodes. Applications modify
their own replica and propagate the effects of their changes to their peers.
Lasp ensures that applications converge to the same result on every node
through the use of data structures known as Conflict-Free Replicated Data
Types, combined with monotone programming. For our Lasp evaluation, the
application is a simulated advertisement counter, modeled after the Rovio
advertisement counter scenario for Angry Birds. In this application, each
client keeps a replica of a grow-only distributed counterissuing increment
operations when an advertisement is displayed. Once a certain number of
impressions is reached, the advertisement is disabled. The increment interval
was fixed at 10s, and the propagation interval for the counter was fixed at
5s. The total number of impressions was configured to ensure that the
experiment would run for 30 minutes under all configurations. The evaluation
is performed on both the client-server and peer-to-peer overlays for
different cluster sizes, ranging from 32 all the way up to 1,024 node
clusters.</p>

<p>For both overlays, the system propagates the full state of the counter to the
node’s peers at each propagation interval. Note that since the Rovio
advertisement counter scenario was designed for mobile applications, we do
not run the fullmesh topology because it would be unrealistic. That is, in
the context of mobile apps, clients would not connect to all other nodes, nor
will they have knowledge of who all of the clients in the system are. Rather,
either mobile apps will communicate with some number of nearby peers
(peer-to-peer) or they will communicate through a server (client-server).
Clientserver also serves as the standard model of deploying mobile
applications today. Thus, we designed our experiments to reflect this—we
examine client-server and peer-to-peer overlays for this application in our
experiments.</p>

<p>We present the total data transmission required for the experiment to finish
as we scale the size of the cluster from 32 to 1024 nodes. For smaller
clusters of nodes, client-server is the more efficient overlay in terms of
the amount of data that must be transmitted to finish the experiment. This
improved efficiency comes at a cost, however, as the client-server
configuration is unable to scale beyond 256 nodes. Beyond 256 nodes, the
cilent-server experiments could not be completed; as the Erlang VM has
unbounded queues, when the server cannot process incoming messages quickly
enough, the VM allocates all available memory, leading to termination of the
Erlang VM by the Linux OOM Killer. Peer-to-peer is more resilient in the face
of a node failure allowing it to support larger clusters of nodes—up to 1024!
However, peer-to-peer is less efficient due to this—the redundancy of
communication links used by the overlay causes it to transmit more data in
order to complete the experiments.</p>

<p><img src="img/scale.JPG" alt="Cluster Scalability" class="graph" /></p>

<p>Perhaps the most interesting takeaway from the results of this real-world
large-scale experiment is that the experiment was even possible at all with
Erlang. As Distributed Erlang permits one to only use a full-mesh overlay,
it’s possible that the previous results observed by Ericsson on the maximum
size of Erlang clusters–only 200 nodes–are due to this full-mesh-only
restriction. This experiment suggests that Partisan may enable the
development of new applications with actors systems that have not been
previously possible by enabling the application developer to dynamically
change the pattern of communication between nodes, without altering
application semantics. Perhaps the lack of mobile applications written using
distributed actor systems is a symptom of the full-mesh-only restriction.
Similarly, this observation may also hold true for the emerging class of
“Internet of Things” applications.</p>

        </div>
    </div>

</div>
</div>

</section>

<footer>
    <div class="container">
        <div class="row final">
            <div class="col-md-8">
                
                <p class="copyright text-muted small">Copyright &copy; Christopher Meiklejohn. All Rights Reserved.</p>
            </div>
            <div class="col-md-4">
                <img src="/img/CMU_wordmark_1500px-min.png" style="width: 250px; margin-top: 20px;" />
                <img src="/img/baskin-logo-banner-new.png" style="width: 250px; margin-top: 20px;" />
            </div>
        </div>
    </div>
</footer>

<script src="/js/jquery-1.11.0.js"></script>


<script src="/js/jquery.easing.min.js"></script>


<script src="/js/bootstrap.min.js"></script>


<script src="js/landing-page.js"></script>



</body>
</html>

